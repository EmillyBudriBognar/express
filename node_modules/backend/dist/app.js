import { getConnection } from './bd.js';
/**
 * Classe responsável por todas as operações CRUD no banco de dados
 *
 * BOAS PRÁTICAS IMPLEMENTADAS:
 * - Uso de pool de conexões (reutilização eficiente)
 * - Prepared statements (proteção contra SQL injection)
 * - Tratamento adequado de erros com mensagens descritivas
 * - Sempre libera conexões no finally (evita vazamento de recursos)
 * - Validação de dados antes de executar queries
 */
export class App {
    /**
     * Lista todos os estudantes cadastrados
     *
     * @returns Promise com array de estudantes
     * @throws Error se houver falha na conexão ou query
     */
    async executeSearchQuery() {
        let conn;
        try {
            // Obtém uma conexão do pool (não cria nova conexão)
            conn = await getConnection();
            // Prepared statement: protege contra SQL injection
            const sql = "SELECT * FROM estudante ORDER BY id";
            const [rows] = await conn.query(sql);
            return rows;
        }
        catch (error) {
            // Log detalhado do erro para facilitar debug
            console.error("[DB] Erro ao buscar estudantes:", error);
            // Re-throw com mensagem mais descritiva
            if (error instanceof Error) {
                throw new Error(`Falha ao buscar estudantes: ${error.message}`);
            }
            throw new Error('Erro desconhecido ao buscar estudantes');
        }
        finally {
            // IMPORTANTE: Sempre libera a conexão de volta para o pool
            // Isso permite que outras operações reutilizem a conexão
            if (conn) {
                conn.release(); // Libera a conexão (não fecha, apenas retorna ao pool)
            }
        }
    }
    /**
     * Busca um estudante específico por ID
     *
     * @param id - ID do estudante a ser buscado
     * @returns Promise com o estudante encontrado ou null se não existir
     * @throws Error se houver falha na conexão ou query
     */
    async searchQueryById(id) {
        // Validação de entrada
        if (!id || id <= 0 || !Number.isInteger(id)) {
            throw new Error('ID inválido: deve ser um número inteiro positivo');
        }
        let conn;
        try {
            conn = await getConnection();
            // Prepared statement com parâmetro: protege contra SQL injection
            const sql = "SELECT * FROM estudante WHERE id = ?";
            const [rows] = await conn.query(sql, [id]);
            // Retorna o primeiro resultado ou null se não encontrado
            return rows.length > 0 ? rows[0] : null;
        }
        catch (error) {
            console.error(`[DB] Erro ao buscar estudante com ID ${id}:`, error);
            if (error instanceof Error) {
                throw new Error(`Falha ao buscar estudante: ${error.message}`);
            }
            throw new Error('Erro desconhecido ao buscar estudante');
        }
        finally {
            if (conn) {
                conn.release();
            }
        }
    }
    /**
     * Insere um novo estudante no banco de dados
     *
     * @param nome - Nome do estudante (obrigatório)
     * @param email - Email do estudante (opcional)
     * @returns Promise com o resultado da inserção (inclui o ID gerado)
     * @throws Error se houver falha na conexão, query ou validação
     */
    async insertQuery(nome, email) {
        // Validação de entrada
        if (!nome || nome.trim().length === 0) {
            throw new Error('Nome é obrigatório e não pode estar vazio');
        }
        // Validação básica de email (se fornecido)
        if (email && email.trim().length > 0) {
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                throw new Error('Formato de email inválido');
            }
        }
        let conn;
        try {
            conn = await getConnection();
            // Prepared statement: protege contra SQL injection
            // Usa SET ? para permitir inserção parcial de campos
            const sql = "INSERT INTO estudante SET ?";
            const dados = {
                nome: nome.trim(),
                email: email ? email.trim() : null
            };
            const [result] = await conn.query(sql, [dados]);
            return result;
        }
        catch (error) {
            console.error("[DB] Erro ao inserir estudante:", error);
            // Tratamento específico para erros comuns do MySQL
            if (error instanceof Error) {
                // Duplicação de email (se houver constraint unique)
                if (error.message.includes('Duplicate entry')) {
                    throw new Error('Email já cadastrado no sistema');
                }
                // Outros erros de constraint
                if (error.message.includes('constraint')) {
                    throw new Error('Violação de regra do banco de dados');
                }
                throw new Error(`Falha ao inserir estudante: ${error.message}`);
            }
            throw new Error('Erro desconhecido ao inserir estudante');
        }
        finally {
            if (conn) {
                conn.release();
            }
        }
    }
    /**
     * Atualiza os dados de um estudante existente
     *
     * @param id - ID do estudante a ser atualizado
     * @param nome - Novo nome (opcional)
     * @param email - Novo email (opcional)
     * @returns Promise com o resultado da atualização
     * @throws Error se houver falha na conexão, query ou validação
     */
    async updateQuery(id, nome, email) {
        // Validação de entrada
        if (!id || id <= 0 || !Number.isInteger(id)) {
            throw new Error('ID inválido: deve ser um número inteiro positivo');
        }
        // Verifica se pelo menos um campo foi fornecido para atualização
        const dadosParaAtualizar = {};
        if (nome !== undefined) {
            if (nome.trim().length === 0) {
                throw new Error('Nome não pode estar vazio');
            }
            dadosParaAtualizar.nome = nome.trim();
        }
        if (email !== undefined) {
            if (email.trim().length > 0) {
                // Validação de email
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                if (!emailRegex.test(email)) {
                    throw new Error('Formato de email inválido');
                }
                dadosParaAtualizar.email = email.trim();
            }
            else {
                dadosParaAtualizar.email = null; // Permite limpar o email
            }
        }
        // Se nenhum campo foi fornecido, não há nada para atualizar
        if (Object.keys(dadosParaAtualizar).length === 0) {
            return { affectedRows: 0, insertId: 0, warningStatus: 0 };
        }
        let conn;
        try {
            conn = await getConnection();
            // Prepared statement: protege contra SQL injection
            const sql = "UPDATE estudante SET ? WHERE id = ?";
            const [result] = await conn.query(sql, [dadosParaAtualizar, id]);
            return result;
        }
        catch (error) {
            console.error(`[DB] Erro ao atualizar estudante com ID ${id}:`, error);
            if (error instanceof Error) {
                if (error.message.includes('Duplicate entry')) {
                    throw new Error('Email já cadastrado no sistema');
                }
                throw new Error(`Falha ao atualizar estudante: ${error.message}`);
            }
            throw new Error('Erro desconhecido ao atualizar estudante');
        }
        finally {
            if (conn) {
                conn.release();
            }
        }
    }
    /**
     * Remove um estudante do banco de dados
     *
     * @param id - ID do estudante a ser removido
     * @returns Promise com o resultado da deleção
     * @throws Error se houver falha na conexão ou query
     */
    async deleteQuery(id) {
        // Validação de entrada
        if (!id || id <= 0 || !Number.isInteger(id)) {
            throw new Error('ID inválido: deve ser um número inteiro positivo');
        }
        let conn;
        try {
            conn = await getConnection();
            // Prepared statement: protege contra SQL injection
            const sql = "DELETE FROM estudante WHERE id = ?";
            const [result] = await conn.query(sql, [id]);
            return result;
        }
        catch (error) {
            console.error(`[DB] Erro ao deletar estudante com ID ${id}:`, error);
            if (error instanceof Error) {
                // Erro de foreign key constraint (se houver relacionamentos)
                if (error.message.includes('foreign key constraint')) {
                    throw new Error('Não é possível deletar este estudante pois possui registros relacionados');
                }
                throw new Error(`Falha ao deletar estudante: ${error.message}`);
            }
            throw new Error('Erro desconhecido ao deletar estudante');
        }
        finally {
            if (conn) {
                conn.release();
            }
        }
    }
}
//# sourceMappingURL=app.js.map