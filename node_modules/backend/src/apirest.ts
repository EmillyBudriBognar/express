import express, { type Request, type Response } from 'express';
import { App } from './app.js';
import { getPool, closePool } from './bd.js';
import cors from 'cors';

// Carrega variáveis de ambiente (importante para dotenv funcionar)
import 'dotenv/config';

const app = express();
const porta = process.env.PORT || 3000;

app.use(express.json());
app.use(cors());

// Inicializa o pool de conexões na inicialização da aplicação
// Isso garante que o pool esteja pronto antes de processar requisições
try {
  getPool();
  console.log('[API] Pool de conexões inicializado com sucesso');
} catch (error) {
  console.error('[API] ERRO CRÍTICO: Não foi possível inicializar o pool de conexões:', error);
  process.exit(1); // Encerra a aplicação se não conseguir conectar ao banco
}

const crud = new App();

app.get('/usuarios', async (_req: Request, res: Response) => {
    try {
        const usuarios = await crud.executeSearchQuery();
        res.status(200).json(usuarios);
    } catch (error) {
        console.error('Erro ao listar usuários:', error);
        res.status(500).json({ message: 'Erro interno do servidor ao listar usuários.' });
    }
});

app.get('/usuarios/:id', async (req: Request, res: Response) => {
    if (!req.params.id) {
        return res.status(400).json({ message: 'ID de usuário inválido.' });
    }
    const id = parseInt(req.params.id);
    if (isNaN(id)) return res.status(400).json({ message: 'ID de usuário inválido.' });

    try {
        const usuario = await crud.searchQueryById(id);
        if (!usuario) return res.status(404).json({ message: 'Usuário não encontrado.' });
        res.status(200).json(usuario);
    } catch (error) {
        console.error(`Erro ao buscar usuário ${id}:`, error);
        res.status(500).json({ message: 'Erro interno do servidor ao buscar usuário.' });
    }
});

app.post('/usuarios', async (req: Request, res: Response) => {
    const { nome, email } = req.body;
    
    // Validação: nome é obrigatório, email é opcional
    if (!nome || nome.trim().length === 0) {
        return res.status(400).json({ message: 'Nome é obrigatório e não pode estar vazio.' });
    }

    try {
        const novoUsuario = await crud.insertQuery(nome, email);
        res.status(201).json({ 
            message: 'Usuário inserido com sucesso!', 
            id: novoUsuario.insertId,
            affectedRows: novoUsuario.affectedRows
        });
    } catch (error) {
        console.error('[API] Erro ao inserir usuário:', error);
        
        // Retorna mensagem de erro mais específica
        const errorMessage = error instanceof Error ? error.message : 'Erro interno do servidor ao inserir usuário.';
        const statusCode = errorMessage.includes('obrigatório') || errorMessage.includes('inválido') ? 400 : 500;
        
        res.status(statusCode).json({ message: errorMessage });
    }
});

app.put('/usuarios', async (req: Request, res: Response) => {
    const { id, nome, email } = req.body;

    if (isNaN(id)) return res.status(400).json({ message: 'ID de usuário inválido.' });
    if (!nome && !email) return res.status(400).json({ message: 'Informe ao menos nome ou email para atualização.' });

    try {
        await crud.updateQuery(id, nome, email);
        res.status(200).json({ message: `Usuário ${id} atualizado com sucesso!` });
    } catch (error) {
        console.error(`Erro ao atualizar usuário ${id}:`, error);
        res.status(500).json({ message: 'Erro interno do servidor ao atualizar usuário.' });
    }
});

app.delete('/usuarios/:id', async (req: Request, res: Response) => {
    if (!req.params.id) {
        return res.status(400).json({ message: 'ID de usuário inválido.' });
    }
    const id = parseInt(req.params.id);
    if (isNaN(id)) return res.status(400).json({ message: 'ID de usuário inválido.' });

    try {
        await crud.deleteQuery(id);
        res.status(204).send();
    } catch (error) {
        console.error(`Erro ao deletar usuário ${id}:`, error);
        res.status(500).json({ message: 'Erro interno do servidor ao deletar usuário.' });
    }
});

// Inicia o servidor HTTP
const server = app.listen(porta, () => {
    console.log(`[API] API RESTful rodando em: http://localhost:${porta}`);
    console.log(`[API] Ambiente: ${process.env.NODE_ENV || 'development'}`);
});

// Handler para encerramento graceful da aplicação
// Fecha o pool de conexões e o servidor HTTP corretamente quando a aplicação é encerrada
const gracefulShutdown = async (signal: string) => {
  console.log(`\n[API] Recebido sinal ${signal}. Encerrando aplicação...`);
  
  // Fecha o servidor HTTP primeiro (para não aceitar novas requisições)
  return new Promise<void>((resolve) => {
    server.close(async () => {
      console.log('[API] Servidor HTTP fechado');
      
      try {
        // Depois fecha o pool de conexões do banco de dados
        await closePool();
        console.log('[API] Pool de conexões fechado com sucesso');
        resolve();
        process.exit(0);
      } catch (error) {
        console.error('[API] Erro ao fechar pool de conexões:', error);
        resolve();
        process.exit(1);
      }
    });
    
    // Timeout: força o encerramento após 10 segundos se não conseguir fechar graciosamente
    setTimeout(() => {
      console.error('[API] Timeout ao encerrar aplicação. Forçando encerramento...');
      process.exit(1);
    }, 10000);
  });
};

// Registra handlers para diferentes sinais de encerramento
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

// Handler para erros não tratados
process.on('unhandledRejection', (reason, promise) => {
  console.error('[API] Unhandled Rejection at:', promise, 'reason:', reason);
});

process.on('uncaughtException', (error) => {
  console.error('[API] Uncaught Exception:', error);
  gracefulShutdown('uncaughtException');
});
